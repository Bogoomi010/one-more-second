{"ast":null,"code":"var _jsxFileName = \"/Users/kbk-admin/one-more-second/src/pages/Game/components/GameCanvas.tsx\",\n  _s = $RefreshSig$();\nimport { useEffect, useRef, useState } from \"react\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst CANVAS_WIDTH = 480;\nconst CANVAS_HEIGHT = 640;\nconst PLAYER_SPEED = 4;\nconst PLAYER_SIZE = 20;\nconst BULLET_RADIUS = 4;\nconst BULLET_SPEED = 3;\nconst INITIAL_SPAWN_INTERVAL = 500;\nconst INTERVAL_DECREASE = 50;\nconst MIN_SPAWN_INTERVAL = 100;\nconst DIFFICULTY_INTERVAL = 3000; // 3초\n\n// 플레이어 시작 위치 상수 추가\nconst PLAYER_START_X = CANVAS_WIDTH / 2 - PLAYER_SIZE / 2;\nconst PLAYER_START_Y = CANVAS_HEIGHT / 2 - PLAYER_SIZE / 2;\nexport default function GameCanvas({\n  lives,\n  setLives,\n  setSpawnIntervalStatus\n}) {\n  _s();\n  const canvasRef = useRef(null);\n  const keysRef = useRef({\n    ArrowLeft: false,\n    ArrowRight: false,\n    ArrowUp: false,\n    ArrowDown: false\n  });\n  const playerRef = useRef({\n    x: PLAYER_START_X,\n    y: PLAYER_START_Y\n  });\n  const bulletsRef = useRef([]);\n  const startTimeRef = useRef(Date.now());\n  const gameOverRef = useRef(false);\n  const animationRef = useRef(undefined);\n  const spawnLoopRef = useRef(undefined);\n  const difficultyLoopRef = useRef(undefined);\n  const livesRef = useRef(lives);\n  const isHitRef = useRef(false);\n  const isTopSpawnRef = useRef(true);\n  const [spawnInterval, setSpawnInterval] = useState(INITIAL_SPAWN_INTERVAL);\n  function spawnSingleBullet() {\n    // 화면 상단 또는 하단에서 랜덤한 X 좌표 선택\n    const margin = BULLET_RADIUS * 2;\n    const centerX = Math.random() * (CANVAS_WIDTH - margin * 2) + margin;\n\n    // 현재 스폰 위치에 따라 Y 좌표와 각도 계산\n    const centerY = isTopSpawnRef.current ? BULLET_RADIUS * 2 : CANVAS_HEIGHT - BULLET_RADIUS * 2;\n\n    // 플레이어를 향해 발사되도록 각도 계산\n    const targetAngle = Math.atan2(playerRef.current.y + PLAYER_SIZE / 2 - centerY, playerRef.current.x + PLAYER_SIZE / 2 - centerX);\n    const bullet = {\n      x: centerX,\n      y: centerY,\n      angle: targetAngle,\n      speed: BULLET_SPEED\n    };\n    bulletsRef.current.push(bullet);\n\n    // 다음 발사는 반대쪽에서 하도록 토글\n    isTopSpawnRef.current = !isTopSpawnRef.current;\n  }\n\n  // lives 값이 변경될 때마다 ref 업데이트\n  useEffect(() => {\n    livesRef.current = lives;\n  }, [lives]);\n\n  // spawnInterval이 변경될 때마다 상태 업데이트\n  useEffect(() => {\n    setSpawnIntervalStatus(spawnInterval);\n  }, [spawnInterval, setSpawnIntervalStatus]);\n\n  // spawnInterval이 변경될 때마다 총알 생성 인터벌 재설정\n  useEffect(() => {\n    if (spawnLoopRef.current) {\n      clearInterval(spawnLoopRef.current);\n    }\n    spawnLoopRef.current = setInterval(() => {\n      if (!gameOverRef.current) {\n        spawnSingleBullet();\n      }\n    }, spawnInterval);\n    return () => {\n      if (spawnLoopRef.current) {\n        clearInterval(spawnLoopRef.current);\n      }\n    };\n  }, [spawnInterval]);\n  useEffect(() => {\n    const canvas = canvasRef.current;\n    const ctx = canvas === null || canvas === void 0 ? void 0 : canvas.getContext(\"2d\");\n    if (!canvas || !ctx) return;\n    function resetGame() {\n      gameOverRef.current = false;\n      playerRef.current = {\n        x: PLAYER_START_X,\n        y: PLAYER_START_Y\n      };\n      bulletsRef.current = [];\n      startTimeRef.current = Date.now();\n      isHitRef.current = false;\n      isTopSpawnRef.current = true;\n      setSpawnInterval(INITIAL_SPAWN_INTERVAL);\n      setLives(3);\n\n      // 기존 인터벌 제거\n      if (difficultyLoopRef.current) clearInterval(difficultyLoopRef.current);\n\n      // 난이도 증가 인터벌 설정\n      difficultyLoopRef.current = setInterval(() => {\n        if (!gameOverRef.current) {\n          setSpawnInterval(prev => Math.max(MIN_SPAWN_INTERVAL, prev - INTERVAL_DECREASE));\n        }\n      }, DIFFICULTY_INTERVAL);\n      gameLoop();\n    }\n    function handleKeyDown(e) {\n      if ([\"ArrowLeft\", \"ArrowRight\", \"ArrowUp\", \"ArrowDown\"].includes(e.key)) {\n        e.preventDefault();\n      }\n      keysRef.current[e.key] = true;\n      if (gameOverRef.current && e.key === \"r\") {\n        resetGame();\n      }\n    }\n    function handleKeyUp(e) {\n      keysRef.current[e.key] = false;\n    }\n    window.addEventListener(\"keydown\", handleKeyDown);\n    window.addEventListener(\"keyup\", handleKeyUp);\n    function checkCollision(px, py, bx, by, br) {\n      const dx = px + PLAYER_SIZE / 2 - bx;\n      const dy = py + PLAYER_SIZE / 2 - by;\n      const distance = Math.sqrt(dx * dx + dy * dy);\n      return distance < br + PLAYER_SIZE / 2;\n    }\n    function handleCollision() {\n      isHitRef.current = true;\n      setTimeout(() => {\n        isHitRef.current = false;\n      }, 150);\n      if (livesRef.current > 1) {\n        setLives(livesRef.current - 1);\n      } else {\n        gameOverRef.current = true;\n        setLives(0);\n        cancelAnimationFrame(animationRef.current);\n        clearInterval(spawnLoopRef.current);\n        clearInterval(difficultyLoopRef.current);\n      }\n    }\n    function update() {\n      if (gameOverRef.current) return;\n      const keys = keysRef.current;\n      if (keys.ArrowLeft) playerRef.current.x -= PLAYER_SPEED;\n      if (keys.ArrowRight) playerRef.current.x += PLAYER_SPEED;\n      if (keys.ArrowUp) playerRef.current.y -= PLAYER_SPEED;\n      if (keys.ArrowDown) playerRef.current.y += PLAYER_SPEED;\n      playerRef.current.x = Math.max(0, Math.min(CANVAS_WIDTH - PLAYER_SIZE, playerRef.current.x));\n      playerRef.current.y = Math.max(0, Math.min(CANVAS_HEIGHT - PLAYER_SIZE, playerRef.current.y));\n      bulletsRef.current.forEach(b => {\n        b.x += Math.cos(b.angle) * b.speed;\n        b.y += Math.sin(b.angle) * b.speed;\n      });\n      for (const b of bulletsRef.current) {\n        if (checkCollision(playerRef.current.x, playerRef.current.y, b.x, b.y, BULLET_RADIUS)) {\n          bulletsRef.current = bulletsRef.current.filter(bullet => bullet !== b);\n          handleCollision();\n          return;\n        }\n      }\n      bulletsRef.current = bulletsRef.current.filter(b => b.x >= 0 && b.x <= CANVAS_WIDTH && b.y >= 0 && b.y <= CANVAS_HEIGHT);\n    }\n    function draw() {\n      if (!ctx) return;\n\n      // 배경을 어두운색으로 채우기\n      ctx.fillStyle = \"#18181b\";\n      ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n      // 피격 시 붉은색 오버레이\n      if (isHitRef.current) {\n        ctx.fillStyle = \"rgba(255, 0, 0, 0.5)\";\n        ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n      }\n\n      // 플레이어 그리기\n      ctx.fillStyle = \"#00f\";\n      ctx.fillRect(playerRef.current.x, playerRef.current.y, PLAYER_SIZE, PLAYER_SIZE);\n\n      // 총알 그리기\n      ctx.fillStyle = \"#f00\";\n      bulletsRef.current.forEach(b => {\n        ctx.beginPath();\n        ctx.arc(b.x, b.y, BULLET_RADIUS, 0, Math.PI * 2);\n        ctx.fill();\n      });\n\n      // 시간과 생명 표시\n      const elapsedSec = Math.floor((Date.now() - startTimeRef.current) / 1000);\n      ctx.fillStyle = \"#fff\";\n      ctx.font = \"16px monospace\";\n      ctx.fillText(`Survived: ${elapsedSec}s`, 10, 20);\n      ctx.fillText(`Lives: ${livesRef.current}`, 10, 40);\n      ctx.fillText(`Interval: ${spawnInterval}ms`, 10, 60);\n      if (gameOverRef.current) {\n        ctx.fillStyle = \"#fff\";\n        ctx.font = \"bold 32px monospace\";\n        ctx.textAlign = \"center\";\n        ctx.fillText(\"GAME OVER\", CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2);\n        ctx.font = \"16px monospace\";\n        ctx.fillText(\"Press R to Restart\", CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 + 30);\n        ctx.textAlign = \"left\";\n      }\n    }\n    function gameLoop() {\n      update();\n      draw();\n      if (!gameOverRef.current) {\n        animationRef.current = requestAnimationFrame(gameLoop);\n      }\n    }\n\n    // 초기 게임 시작\n    resetGame();\n    return () => {\n      cancelAnimationFrame(animationRef.current);\n      clearInterval(spawnLoopRef.current);\n      clearInterval(difficultyLoopRef.current);\n      window.removeEventListener(\"keydown\", handleKeyDown);\n      window.removeEventListener(\"keyup\", handleKeyUp);\n    };\n  }, [setLives]);\n  return /*#__PURE__*/_jsxDEV(\"canvas\", {\n    ref: canvasRef,\n    width: CANVAS_WIDTH,\n    height: CANVAS_HEIGHT,\n    style: {\n      display: 'block',\n      margin: '0 auto',\n      background: '#18181b',\n      border: '2px solid #222',\n      maxWidth: 480,\n      height: 640\n    }\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 257,\n    columnNumber: 5\n  }, this);\n}\n_s(GameCanvas, \"0Caqb1GrD7pv2MxzM6e3EAWGWBM=\");\n_c = GameCanvas;\nvar _c;\n$RefreshReg$(_c, \"GameCanvas\");","map":{"version":3,"names":["useEffect","useRef","useState","jsxDEV","_jsxDEV","CANVAS_WIDTH","CANVAS_HEIGHT","PLAYER_SPEED","PLAYER_SIZE","BULLET_RADIUS","BULLET_SPEED","INITIAL_SPAWN_INTERVAL","INTERVAL_DECREASE","MIN_SPAWN_INTERVAL","DIFFICULTY_INTERVAL","PLAYER_START_X","PLAYER_START_Y","GameCanvas","lives","setLives","setSpawnIntervalStatus","_s","canvasRef","keysRef","ArrowLeft","ArrowRight","ArrowUp","ArrowDown","playerRef","x","y","bulletsRef","startTimeRef","Date","now","gameOverRef","animationRef","undefined","spawnLoopRef","difficultyLoopRef","livesRef","isHitRef","isTopSpawnRef","spawnInterval","setSpawnInterval","spawnSingleBullet","margin","centerX","Math","random","centerY","current","targetAngle","atan2","bullet","angle","speed","push","clearInterval","setInterval","canvas","ctx","getContext","resetGame","prev","max","gameLoop","handleKeyDown","e","includes","key","preventDefault","handleKeyUp","window","addEventListener","checkCollision","px","py","bx","by","br","dx","dy","distance","sqrt","handleCollision","setTimeout","cancelAnimationFrame","update","keys","min","forEach","b","cos","sin","filter","draw","fillStyle","fillRect","beginPath","arc","PI","fill","elapsedSec","floor","font","fillText","textAlign","requestAnimationFrame","removeEventListener","ref","width","height","style","display","background","border","maxWidth","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["/Users/kbk-admin/one-more-second/src/pages/Game/components/GameCanvas.tsx"],"sourcesContent":["import { useEffect, useRef, useState } from \"react\";\n\nconst CANVAS_WIDTH = 480;\nconst CANVAS_HEIGHT = 640;\nconst PLAYER_SPEED = 4;\nconst PLAYER_SIZE = 20;\nconst BULLET_RADIUS = 4;\nconst BULLET_SPEED = 3;\nconst INITIAL_SPAWN_INTERVAL = 500;\nconst INTERVAL_DECREASE = 50;\nconst MIN_SPAWN_INTERVAL = 100;\nconst DIFFICULTY_INTERVAL = 3000; // 3초\n\n// 플레이어 시작 위치 상수 추가\nconst PLAYER_START_X = CANVAS_WIDTH / 2 - PLAYER_SIZE / 2;\nconst PLAYER_START_Y = CANVAS_HEIGHT / 2 - PLAYER_SIZE / 2;\n\ninterface GameCanvasProps {\n  lives: number;\n  setLives: (lives: number) => void;\n  setSpawnIntervalStatus: (interval: number) => void;\n}\n\nexport default function GameCanvas({ lives, setLives, setSpawnIntervalStatus }: GameCanvasProps) {\n  const canvasRef = useRef<HTMLCanvasElement | null>(null);\n  const keysRef = useRef({ ArrowLeft: false, ArrowRight: false, ArrowUp: false, ArrowDown: false });\n  const playerRef = useRef({ x: PLAYER_START_X, y: PLAYER_START_Y });\n  const bulletsRef = useRef<any[]>([]);\n  const startTimeRef = useRef(Date.now());\n  const gameOverRef = useRef(false);\n  const animationRef = useRef<number | undefined>(undefined);\n  const spawnLoopRef = useRef<NodeJS.Timeout | undefined>(undefined);\n  const difficultyLoopRef = useRef<NodeJS.Timeout | undefined>(undefined);\n  const livesRef = useRef(lives);\n  const isHitRef = useRef(false);\n  const isTopSpawnRef = useRef(true);\n  const [spawnInterval, setSpawnInterval] = useState(INITIAL_SPAWN_INTERVAL);\n\n  function spawnSingleBullet() {\n    // 화면 상단 또는 하단에서 랜덤한 X 좌표 선택\n    const margin = BULLET_RADIUS * 2;\n    const centerX = Math.random() * (CANVAS_WIDTH - margin * 2) + margin;\n    \n    // 현재 스폰 위치에 따라 Y 좌표와 각도 계산\n    const centerY = isTopSpawnRef.current ? BULLET_RADIUS * 2 : CANVAS_HEIGHT - BULLET_RADIUS * 2;\n    \n    // 플레이어를 향해 발사되도록 각도 계산\n    const targetAngle = Math.atan2(\n      playerRef.current.y + PLAYER_SIZE / 2 - centerY,\n      playerRef.current.x + PLAYER_SIZE / 2 - centerX\n    );\n    \n    const bullet = {\n      x: centerX,\n      y: centerY,\n      angle: targetAngle,\n      speed: BULLET_SPEED\n    };\n    \n    bulletsRef.current.push(bullet);\n    \n    // 다음 발사는 반대쪽에서 하도록 토글\n    isTopSpawnRef.current = !isTopSpawnRef.current;\n  }\n\n  // lives 값이 변경될 때마다 ref 업데이트\n  useEffect(() => {\n    livesRef.current = lives;\n  }, [lives]);\n\n  // spawnInterval이 변경될 때마다 상태 업데이트\n  useEffect(() => {\n    setSpawnIntervalStatus(spawnInterval);\n  }, [spawnInterval, setSpawnIntervalStatus]);\n\n  // spawnInterval이 변경될 때마다 총알 생성 인터벌 재설정\n  useEffect(() => {\n    if (spawnLoopRef.current) {\n      clearInterval(spawnLoopRef.current);\n    }\n    \n    spawnLoopRef.current = setInterval(() => {\n      if (!gameOverRef.current) {\n        spawnSingleBullet();\n      }\n    }, spawnInterval);\n\n    return () => {\n      if (spawnLoopRef.current) {\n        clearInterval(spawnLoopRef.current);\n      }\n    };\n  }, [spawnInterval]);\n\n  useEffect(() => {\n    const canvas = canvasRef.current;\n    const ctx = canvas?.getContext(\"2d\");\n    if (!canvas || !ctx) return;\n\n    function resetGame() {\n      gameOverRef.current = false;\n      playerRef.current = { x: PLAYER_START_X, y: PLAYER_START_Y };\n      bulletsRef.current = [];\n      startTimeRef.current = Date.now();\n      isHitRef.current = false;\n      isTopSpawnRef.current = true;\n      setSpawnInterval(INITIAL_SPAWN_INTERVAL);\n      setLives(3);\n\n      // 기존 인터벌 제거\n      if (difficultyLoopRef.current) clearInterval(difficultyLoopRef.current);\n      \n      // 난이도 증가 인터벌 설정\n      difficultyLoopRef.current = setInterval(() => {\n        if (!gameOverRef.current) {\n          setSpawnInterval(prev => Math.max(MIN_SPAWN_INTERVAL, prev - INTERVAL_DECREASE));\n        }\n      }, DIFFICULTY_INTERVAL);\n\n      gameLoop();\n    }\n\n    function handleKeyDown(e: KeyboardEvent) {\n      if ([\"ArrowLeft\", \"ArrowRight\", \"ArrowUp\", \"ArrowDown\"].includes(e.key)) {\n        e.preventDefault();\n      }\n      keysRef.current[e.key as keyof typeof keysRef.current] = true;\n      if (gameOverRef.current && e.key === \"r\") {\n        resetGame();\n      }\n    }\n\n    function handleKeyUp(e: KeyboardEvent) {\n      keysRef.current[e.key as keyof typeof keysRef.current] = false;\n    }\n\n    window.addEventListener(\"keydown\", handleKeyDown);\n    window.addEventListener(\"keyup\", handleKeyUp);\n\n    function checkCollision(px: number, py: number, bx: number, by: number, br: number) {\n      const dx = px + PLAYER_SIZE / 2 - bx;\n      const dy = py + PLAYER_SIZE / 2 - by;\n      const distance = Math.sqrt(dx * dx + dy * dy);\n      return distance < br + PLAYER_SIZE / 2;\n    }\n\n    function handleCollision() {\n      isHitRef.current = true;\n      setTimeout(() => {\n        isHitRef.current = false;\n      }, 150);\n      \n      if (livesRef.current > 1) {\n        setLives(livesRef.current - 1);\n      } else {\n        gameOverRef.current = true;\n        setLives(0);\n        cancelAnimationFrame(animationRef.current!);\n        clearInterval(spawnLoopRef.current);\n        clearInterval(difficultyLoopRef.current);\n      }\n    }\n\n    function update() {\n      if (gameOverRef.current) return;\n\n      const keys = keysRef.current;\n      if (keys.ArrowLeft) playerRef.current.x -= PLAYER_SPEED;\n      if (keys.ArrowRight) playerRef.current.x += PLAYER_SPEED;\n      if (keys.ArrowUp) playerRef.current.y -= PLAYER_SPEED;\n      if (keys.ArrowDown) playerRef.current.y += PLAYER_SPEED;\n\n      playerRef.current.x = Math.max(0, Math.min(CANVAS_WIDTH - PLAYER_SIZE, playerRef.current.x));\n      playerRef.current.y = Math.max(0, Math.min(CANVAS_HEIGHT - PLAYER_SIZE, playerRef.current.y));\n\n      bulletsRef.current.forEach((b) => {\n        b.x += Math.cos(b.angle) * b.speed;\n        b.y += Math.sin(b.angle) * b.speed;\n      });\n\n      for (const b of bulletsRef.current) {\n        if (checkCollision(playerRef.current.x, playerRef.current.y, b.x, b.y, BULLET_RADIUS)) {\n          bulletsRef.current = bulletsRef.current.filter((bullet) => bullet !== b);\n          handleCollision();\n          return;\n        }\n      }\n\n      bulletsRef.current = bulletsRef.current.filter((b) => b.x >= 0 && b.x <= CANVAS_WIDTH && b.y >= 0 && b.y <= CANVAS_HEIGHT);\n    }\n\n    function draw() {\n      if (!ctx) return;\n      \n      // 배경을 어두운색으로 채우기\n      ctx.fillStyle = \"#18181b\";\n      ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n      // 피격 시 붉은색 오버레이\n      if (isHitRef.current) {\n        ctx.fillStyle = \"rgba(255, 0, 0, 0.5)\";\n        ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n      }\n\n      // 플레이어 그리기\n      ctx.fillStyle = \"#00f\";\n      ctx.fillRect(playerRef.current.x, playerRef.current.y, PLAYER_SIZE, PLAYER_SIZE);\n\n      // 총알 그리기\n      ctx.fillStyle = \"#f00\";\n      bulletsRef.current.forEach((b) => {\n        ctx.beginPath();\n        ctx.arc(b.x, b.y, BULLET_RADIUS, 0, Math.PI * 2);\n        ctx.fill();\n      });\n\n      // 시간과 생명 표시\n      const elapsedSec = Math.floor((Date.now() - startTimeRef.current) / 1000);\n      ctx.fillStyle = \"#fff\";\n      ctx.font = \"16px monospace\";\n      ctx.fillText(`Survived: ${elapsedSec}s`, 10, 20);\n      ctx.fillText(`Lives: ${livesRef.current}`, 10, 40);\n      ctx.fillText(`Interval: ${spawnInterval}ms`, 10, 60);\n\n      if (gameOverRef.current) {\n        ctx.fillStyle = \"#fff\";\n        ctx.font = \"bold 32px monospace\";\n        ctx.textAlign = \"center\";\n        ctx.fillText(\"GAME OVER\", CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2);\n        ctx.font = \"16px monospace\";\n        ctx.fillText(\"Press R to Restart\", CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 + 30);\n        ctx.textAlign = \"left\";\n      }\n    }\n\n    function gameLoop() {\n      update();\n      draw();\n      if (!gameOverRef.current) {\n        animationRef.current = requestAnimationFrame(gameLoop);\n      }\n    }\n\n    // 초기 게임 시작\n    resetGame();\n\n    return () => {\n      cancelAnimationFrame(animationRef.current!);\n      clearInterval(spawnLoopRef.current);\n      clearInterval(difficultyLoopRef.current);\n      window.removeEventListener(\"keydown\", handleKeyDown);\n      window.removeEventListener(\"keyup\", handleKeyUp);\n    };\n  }, [setLives]);\n\n  return (\n    <canvas\n      ref={canvasRef}\n      width={CANVAS_WIDTH}\n      height={CANVAS_HEIGHT}\n      style={{\n        display: 'block',\n        margin: '0 auto',\n        background: '#18181b',\n        border: '2px solid #222',\n        maxWidth: 480,\n        height: 640\n      }}\n    />\n  );\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}